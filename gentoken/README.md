# Gentoken module

This module generates capture the flag tokens which can be used by other modules to create exercises. Sample Java code is provide in the extras folder to decrypt a token to see which exercise it is for.

**IMPORTANT:** You must change the `aeskey` in `lib/puppet/parser/functions/gentoken.rb` or else anyone can generate their own tokens.

**IMPORTANT:** Puppet should also be removed from the virtual machine after modules have been installed. The source code with the aes key might be copied from the server to the client even though it is only ever run on the server (thanks puppet).

## Requirements

- Changing the `aeskey` as described above

## How to use this module

This module is intended to be used by other modules. To generate the token `ex11`, you would simply call the function `gentoken("ex11")`. This can be used to put the token into a file like this:

```puppet
file { '/tmp/token':
  content => gentoken("ex11"),
}
```

Or used as a parameter for a template:

_File: module/manifests/init.pp_

```puppet
file { '/tmp/token':
  content => epp("module/token", {'token' => gentoken("ex11")}),
}
```

_File: module/templates/token_

```html+erb
<%- | String $token = '' | -%>
Here is the token <%= $token %>
```

## How tokens are made

Each token is a combination of an token identifier and a virtual machine identifier (vmid) encrypted with an aes key using 128 bits in ECB mode with no padding. The encrypted output is encoded into hexadecimal.

The token identifier is specified when the token is generated by passing a string to the `gentoken` function. Because tokens have to be 32 characters, vmid may be cut short based on the length of the token identifier. Token identifiers with more than 16 characters will cause tokens of a larger size and opens the possibility of fake tokens (because the token identifier and vmid are split into separate blocks).

The vmid is the UUID returned by dmidecode combined with the mac address of the network interface eth0 all hashed using the md5 algorithm. This creates a pseudo random 32 character string to identify the virtual machine. I chose to hash the UUID and mac address together so that the vmid could be shortened with relative safety. Without the hash two machines with the same UUID but different mac addresses could end up with the same tokens if all of the mac address gets cut.
